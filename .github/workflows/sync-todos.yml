name: Sync TODOs to Issues

on:
  workflow_dispatch:
  push:
    branches: [ main ]
    paths:
      - 'TODO.md'
      - '.github/workflows/sync-todos.yml'

permissions:
  contents: read
  issues: write

jobs:
  sync:
    runs-on: ubuntu-latest
    concurrency:
      group: sync-todos
      cancel-in-progress: false
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Create/Update Issues from TODO.md
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const crypto = require('crypto');

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const path = 'TODO.md';
            const raw = fs.readFileSync(path, 'utf8');
            const lines = raw.split(/\r?\n/);

            // Parse TODOs under H2/H3 headings
            let h2 = null, h3 = null;
            const todos = [];
            for (let i = 0; i < lines.length; i++) {
              const line = lines[i];
              if (line.startsWith('## ')) {
                h2 = line.replace(/^##\s+/, '').trim();
                h3 = null;
                continue;
              }
              if (line.startsWith('### ')) {
                h3 = line.replace(/^###\s+/, '').trim();
                continue;
              }
              const m = line.match(/^\- \[ \] (.+)$/);
              if (m) {
                const text = m[1].trim();
                const key = crypto.createHash('sha1').update(`${h2 || ''}::${h3 || ''}::${text}`).digest('hex').slice(0, 12);
                todos.push({ line: i + 1, text, h2, h3, key });
              }
            }

            core.info(`Found ${todos.length} unchecked TODO items.`);

            // Fetch existing issues to deduplicate by key marker in body
            const issues = await github.paginate(github.rest.issues.listForRepo, { owner, repo, state: 'all', per_page: 100 });
            const existingKeys = new Set();
            for (const iss of issues) {
              const body = iss.body || '';
              const km = body.match(/<!--\s*todo-key:\s*([a-f0-9]+)\s*-->/i);
              if (km) existingKeys.add(km[1]);
            }

            // Helpers
            async function ensureLabel(name, color, description) {
              try {
                await github.rest.issues.getLabel({ owner, repo, name });
              } catch (e) {
                if (e.status === 404) {
                  await github.rest.issues.createLabel({ owner, repo, name, color, description });
                } else {
                  throw e;
                }
              }
            }

            async function ensureMilestone(title, description) {
              const mls = await github.paginate(github.rest.issues.listMilestones, { owner, repo, state: 'open', per_page: 100 });
              const found = mls.find(m => m.title === title);
              if (found) return found.number;
              const created = await github.rest.issues.createMilestone({ owner, repo, title, description });
              return created.data.number;
            }

            // Prepare common labels
            await ensureLabel('type: todo', '0ea5e9', 'Auto-generated from TODO.md');
            await ensureLabel('section: decisions', '8b5cf6', 'Open decisions and spec errata');
            await ensureLabel('section: cicd', '22c55e', 'CI/CD and release');
            await ensureLabel('stage: P1', 'f97316', 'Product backlog P1');
            await ensureLabel('stage: P2', 'f59e0b', 'Product backlog P2');
            await ensureLabel('stage: P3', 'eab308', 'Product backlog P3');
            await ensureLabel('stage: P4', '84cc16', 'Product backlog P4');

            // Phase labels 1..18
            for (let n = 1; n <= 18; n++) {
              await ensureLabel(`phase: ${n}`, '06b6d4', `Phase ${n}`);
            }

            let createdCount = 0;
            for (const t of todos) {
              if (existingKeys.has(t.key)) {
                core.info(`Skip existing ${t.key}: ${t.text}`);
                continue;
              }

              // Determine labels and milestone based on section
              const labels = ['type: todo'];
              let milestone = undefined;
              let prefix = '[TODO]';

              const phaseMatch = t.h2 && t.h2.match(/^Phase\s+(\d+)/i);
              if (phaseMatch) {
                const pnum = phaseMatch[1];
                labels.push(`phase: ${pnum}`);
                prefix += `[Phase ${pnum}]`;
              } else if (t.h2 && /^Open Decisions/i.test(t.h2)) {
                labels.push('section: decisions');
                prefix += '[Decisions]';
              } else if (t.h2 && /^CI\/CD/i.test(t.h2)) {
                labels.push('section: cicd');
                prefix += '[CI/CD]';
              } else if (t.h2 && /^Product Backlog/i.test(t.h2)) {
                // Backlog stage from H3 like 'P1 (0â€“3 mo)'
                const stage = (t.h3 || '').match(/^P([1-4])\b/)?.[0];
                if (stage) {
                  labels.push(`stage: ${stage}`);
                  prefix += `[${stage}]`;
                  milestone = await ensureMilestone(stage, `Auto-created milestone for ${stage}`);
                }
              }

              const titleBase = `${t.text}`;
              const title = `${prefix} ${titleBase}`.slice(0, 250);
              const body = `<!-- todo-key: ${t.key} -->\n` +
                `Section: ${t.h2 || 'Uncategorized'}${t.h3 ? ' / ' + t.h3 : ''}\n` +
                `Source: https://github.com/${owner}/${repo}/blob/main/TODO.md#L${t.line}\n\n` +
                `Task\n${t.text}\n\n` +
                `Acceptance\n- [ ] Define acceptance criteria for this task\n\n` +
                `Note: Auto-generated from TODO.md via GitHub Actions.`;

              await github.rest.issues.create({ owner, repo, title, body, labels, milestone });
              createdCount++;
            }

            core.summary
              .addHeading('Sync TODOs to Issues')
              .addRaw(`Created ${createdCount} issues; ${todos.length - createdCount} already existed.`)
              .write();
